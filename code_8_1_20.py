"""
    Функция range - 3

Теперь ваша задача создать полную копию встроенного объекта range. Он может
быть вызван от одного, двух или трех аргументов.

    Если вызов происходит от одного аргумента n, то my_range_gen  генерирует
    все числа от 0 до n не включительно.

    Если вызов происходит от двух аргументов a и b, то my_range_gen  генерирует
    все числа от a включительно до b не включительно.

    Если вызов происходит от трех аргументов a , b и step, то my_range_gen
    генерирует все числа от a включительно до b не включительно c шагом step(
    может быть отрицательное значение)

    for i in my_range_gen(4, 8, 2):
        print(i)

    # Будет напечатано
    # 4
    # 6

    for i in my_range_gen(8, 5, -1):
        print(i)

    # Будет напечатано
    # 8
    # 7
    # 6



Предусмотрите вариант запуска my_range_gen со значением step=0. При таком
варианте вызова, функция не должна генерировать ни одной последовательности и
закончить свою работу.

for i in my_range_gen(4, 8, 0):
    print(i) # Ничего не печатает

Такое же поведение должно быть, если переданы нелогичные значения start, stop и
step (см. примеры)

for i in my_range_gen(20, 10, 3):
    print(i)
# Ничего не печатает, потому что нельзя пройти от 20 до 10 с шагом 3


for i in my_range_gen(1, 10, -2):
    print(i)
# Ничего не печатает, потому что нельзя пройти от 1 до 10 с шагом -2

Ваша задача написать только определение функции my_range_gen

    И да, функцией range пользоваться нельзя; можете, конечно, попробовать, но
    у вас ничего не получится
"""

from collections.abc import Iterator


def my_range_gen(
    a: int, b: int | None = None, step: int | None = None
) -> Iterator[int]:
    if step is None:
        i = 0
        if b is not None:
            i = a
            a = b
        while i < a:
            yield i
            i += 1
        return
    elif step == 0:
        return
    elif step != 0:
        if b is None:
            return
        if step > 0:
            while a < b:
                yield a
                a += step
        else:
            while a > b:
                yield a
                a += step
